<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓝桥杯：单词接龙</title>
      <link href="/2020/07/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
      <url>/2020/07/05/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-算法训练-单词接龙"><a href="#蓝桥杯-算法训练-单词接龙" class="headerlink" title="蓝桥杯 算法训练 单词接龙"></a>蓝桥杯 算法训练 单词接龙</h1><p>参考博客：<a href="https://www.cnblogs.com/zbx2000/p/12715400.html" target="_blank" rel="noopener">https://www.cnblogs.com/zbx2000/p/12715400.html</a></p><a id="more"></a><p> <strong>问题描述</strong></p><p>　　单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at 和 atide 间不能相连。</p><p><strong>输入格式</strong></p><p>　　输入的第一行为一个单独的整数n (n&lt;=20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.</p><p><strong>输出格式</strong></p><p>　　只需输出以此字母开头的最长的“龙”的长度</p><p><strong>样例输入</strong><br>　　5<br>　　at<br>　　touch<br>　　cheat<br>　　choose<br>　　tact<br>　　a </p><p><strong>样例输出</strong></p><p>​        23</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//单词数</span></span><br><span class="line"><span class="built_in">string</span> str[N];<span class="comment">//怎么说也要让输入的那些单词有 地方住呀</span></span><br><span class="line">              <span class="comment">//这里的N表示单词数的最多的个数限度</span></span><br><span class="line"><span class="keyword">int</span> g[N][N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//两个单词之间能够重合的最短长度</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//记录龙的长度</span></span><br><span class="line"><span class="keyword">int</span> used[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//每个单词使用的次数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> dragon,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="built_in">max</span>((<span class="keyword">int</span>)dragon.<span class="built_in">size</span>(),ans);</span><br><span class="line">    <span class="comment">//现在龙的长度，强制转换是因为string的size是无符号长整型</span></span><br><span class="line">    </span><br><span class="line">    used[last]++;<span class="comment">//使用次数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找它的下一个单词</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(g[last][i]&amp;&amp;used[i]&lt;<span class="number">2</span>)<span class="comment">//如果跟第i个单词有重复部分，就接上</span></span><br><span class="line">         dfs(dragon+str[i].substr(g[last][i]),i);</span><br><span class="line">    &#125;</span><br><span class="line">   used[last]--;</span><br><span class="line">   <span class="comment">//我来解释一下大多数blog都没讲到的为什么要恢复现场</span></span><br><span class="line">   <span class="comment">//就好比例子来说，touch是第一个被接上的单词</span></span><br><span class="line">   <span class="comment">//那么这个touch在履行完它接龙的责任之后这个循环就结束了呀</span></span><br><span class="line">   <span class="comment">//本来是要由于递归回到at的让人家at继续挑选看看能不能接上其他重合的单词的另一条龙</span></span><br><span class="line">   <span class="comment">//那么好嘞，你at要接上另一条龙了，就说明龙里面已经不是touch作老二了</span></span><br><span class="line">   <span class="comment">//那你是不是要把人家touch还回去，要用的时候再借嘛</span></span><br><span class="line">   <span class="comment">//ok，就是这样。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">char</span> sign;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;sign;<span class="comment">//给定一个开头字母 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//为了枚举字符串之间相同的字串合并形式</span></span><br><span class="line">   <span class="comment">//必须有预处理出来的字符串之间的相同子串邻接表</span></span><br><span class="line">   <span class="comment">//总不能一遍一遍算吧，得有个表</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//也有可能跟自己egtact</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">string</span> a=str[i];<span class="comment">//当前的单词</span></span><br><span class="line">         <span class="built_in">string</span> b=str[j];<span class="comment">//被对照的单词 </span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;<span class="built_in">min</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());k++)</span><br><span class="line">         <span class="comment">//不用等于是因为不能是包含关系</span></span><br><span class="line">         <span class="comment">//k表示重复的字串的字符个数</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(a.substr(a.<span class="built_in">size</span>()-k)==b.substr(<span class="number">0</span>,k))</span><br><span class="line">            <span class="comment">//求最小相同字串才能得出最长的龙</span></span><br><span class="line">            <span class="comment">//重合的越多，龙越短</span></span><br><span class="line">            &#123;</span><br><span class="line">                 g[i][j]=k;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//从第一个单词开始</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(str[i][<span class="number">0</span>]==sign)</span><br><span class="line">          dfs(str[i],i);</span><br><span class="line">          <span class="comment">//第一个参数代表现在的龙的现状</span></span><br><span class="line">          <span class="comment">//第二个参数代表此时操作的单词的坐标</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">          </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>学会的技巧：</p><ol><li>具有重要意义的统一变量最好写在头文件 下来的地方作为全局变量;</li><li>我今天才用到！！！原来字符串数组我不用再 char[][] 了！！！！——直接用 string str[];</li><li>const int 还是很实用的；</li><li>我觉得以后 i，j 这种局部变量还是不要搞成全局变量比较好，容易乱掉，相信我，要用的时候再设。</li><li>substr(i,j)——表示从下标 i 开始截取 j 位</li><li>substr(i)——表示从 i 到结尾的字符串</li><li>利用加号直接连接两个字符串常量，会直接把两个字符连接起来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯：瓷砖铺放</title>
      <link href="/2020/07/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E7%93%B7%E7%A0%96%E9%93%BA%E6%94%BE/"/>
      <url>/2020/07/04/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A%E7%93%B7%E7%A0%96%E9%93%BA%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-算法训练"><a href="#蓝桥杯-算法训练" class="headerlink" title="蓝桥杯 算法训练"></a>蓝桥杯 算法训练</h1><a id="more"></a><p><strong>问题描述</strong></p><p>　　有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？<br>　　例如，长度为4的地面一共有如下5种铺法：<br>　　4=1+1+1+1<br>　　4=2+1+1<br>　　4=1+2+1<br>　　4=1+1+2<br>　　4=2+2<br>　　编程用递归的方法求解上述问题。</p><p><strong>输入格式</strong></p><p>　　只有一个数N，代表地板的长度</p><p><strong>输出格式</strong></p><p>　　输出一个数，代表所有不同的瓷砖铺放方法的总数</p><p><strong>过程：</strong>依次找到递归的规律，此题并不是dp！！！</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*蓝桥杯 算法训练 瓷砖铺放*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/04/Nxp17F.md.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础与提高：Day3 内联函数</title>
      <link href="/2020/07/04/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day3%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>/2020/07/04/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day3%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>近期在学习所谓的”最牛b的c++教程”，做出课程总结。</p><a id="more"></a><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>C++提供了inline关键字，实现了真正的内嵌。</p><p>做出如下对比：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0     <span class="comment">///#if 0 …… #endif相当于注释</span></span></span><br><span class="line">宏函数：</span><br><span class="line">    优点：内嵌代码，避免压栈和出栈的开销。</span><br><span class="line">    缺点：代码替换，容易使生成的代码体积变大，易产生逻辑错误，无类型检查</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) ((x)*(x))</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">inline</span>函数：</span><br><span class="line">    优点：高度抽象，避免重复开发，类型检查</span><br><span class="line">    缺点：压栈和出栈，带来开销</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,SQR(i++));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sqr(i++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型强转"><a href="#类型强转" class="headerlink" title="类型强转"></a>类型强转</h2><p>C++相较于C引进了4新的类型转换操作符</p><h3 id="静态类型转换："><a href="#静态类型转换：" class="headerlink" title="静态类型转换："></a>静态类型转换：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;目标类型&gt;(标识符)</span><br></pre></td></tr></table></figure><p><strong>转换规则</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在一个方向上可以作隐式转换，在另一个方向上就可以作静态转换。*/</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(a)/b&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//float = int  int = float</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="重解释类型转换："><a href="#重解释类型转换：" class="headerlink" title="*重解释类型转换："></a>*重解释类型转换：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reinterpret_cast</span>&lt;目标类型&gt;(标识符)</span><br></pre></td></tr></table></figure><p><strong>转换规则</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通常为操作数的位模式提供较底层的重新解释，也就是说将数据以二进制存在形式的重新解释，在双方向上都不可以隐式类型转换的，则需要重解释类型转换。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0x12345678</span>;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,*p);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> * q =<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(a)+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,*q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脱-常类型转换："><a href="#脱-常类型转换：" class="headerlink" title="(脱)常类型转换："></a>(脱)常类型转换：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;目标类型&gt;(标识符) <span class="comment">//目标类类型只能是指针或者是引用。</span></span><br></pre></td></tr></table></figure><p><strong>语法规则</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用来移除对象的常量性，使用const_cast去除const限定的目的不是为了修改它的内容，而是为了函数能够接受这个实际参数。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; ref)</span> <span class="comment">//别人已经写好的程序或者类库</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ref&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">4444</span>;</span><br><span class="line">    func(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：const_cast可以改变const自定义类的成员变量，但是对于内置数据类型，缺表现未定义行为.</p><p><strong>◇ const常量补充：</strong></p><p>​    C++中const定义的变量称为常变量。<strong>变量的形式，常量的作用，用作常量，常用于取代#define 宏常量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a+b; <span class="comment">//int c = N + b; </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态类型转换："><a href="#动态类型转换：" class="headerlink" title="动态类型转换："></a>动态类型转换：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dynamic)cast&lt;目标类型&gt;(标识符)</span><br><span class="line">    <span class="comment">//用于多态中的父子类之间的强制转化，将会在后序内容中涉及。</span></span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="namespace的作用："><a href="#namespace的作用：" class="headerlink" title="namespace的作用："></a>namespace的作用：</h3><p>​    命名空间为了<strong>大型项目开发</strong>，而引入的一种<strong>避免命名冲突</strong>的一种机制。比如说，在一个大型项目中，要用到多家软件开发商的提供的<strong>类库</strong>。因此为了避免不同<strong>类库</strong>存在同名的函数货值是全局变量而产生冲突。</p><h4 id="语法规则："><a href="#语法规则：" class="headerlink" title="语法规则："></a>语法规则：</h4><p>NameSpace是对全局区域的再次划分。</p><p><strong>声明</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAMESPACE</span><br><span class="line">&#123;</span><br><span class="line">全局变量 <span class="keyword">int</span> a;</span><br><span class="line">数据类型 <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span>&#125;;</span><br><span class="line">    函数 <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    其他命名空间 <span class="keyword">namespace</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>​    1. 直接指定 命名空间： Space : :a = 5;</p><ol start="2"><li><p>使用using+命名空间+元素 ：  using Space: : a; a = 2000 ;</p></li><li><p>使用using + namespace + 命名空间 : using namespace Space ;</p><p>类比std:: cout/using std:: cout using /namespace std;</p><p>​    </p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> MySpace;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MySpace::val = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;MySpace::val;</span><br><span class="line">    <span class="keyword">using</span> MySpace::x;</span><br><span class="line">    <span class="keyword">using</span> MySpace::y;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    y = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> MySpace;</span><br><span class="line">    val = <span class="number">1</span>;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    y = <span class="number">3</span>;</span><br><span class="line">    z = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;val&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持嵌套："><a href="#支持嵌套：" class="headerlink" title="支持嵌套："></a>支持嵌套：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> MySpace;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">namespace</span> Other&#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> MySpace::Other;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯：01背包（dp）</title>
      <link href="/2020/07/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A01%E8%83%8C%E5%8C%85%EF%BC%88dp%EF%BC%89/"/>
      <url>/2020/07/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%9A01%E8%83%8C%E5%8C%85%EF%BC%88dp%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯：01背包问题（动态规划）"><a href="#蓝桥杯：01背包问题（动态规划）" class="headerlink" title="蓝桥杯：01背包问题（动态规划）"></a>蓝桥杯：01背包问题（动态规划）</h1><p><strong>问题描述</strong></p><p>　　给定N个物品,每个物品有一个重量W和一个价值V.你有一个能装M重量的背包.问怎么装使得所装价值最大.每个物品只有一个.</p><a id="more"></a><p><strong>输入格式</strong></p><p>　　输入的第一行包含两个整数n, m，分别表示物品的个数和背包能装重量。<br>　　以后N行每行两个数Wi和Vi,表示物品的重量和价值</p><p><strong>输出格式</strong></p><p>　　输出1行，包含一个整数，表示最大价值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*蓝桥杯算法提高 01背包问题*/</span></span><br><span class="line"><span class="comment">/*2020年7月1日 09:52:30*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,w,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w,&amp;v);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=w;i--)&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i],dp[i-w]+v);<span class="comment">/*意思就是我现在i重的背包里面的价值与目前i-w重的价值加上w重价值，比较，谁大就赋值。*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><p>在CSDN找到一个很好的背包动态规划+最优解回溯的讲解文章：</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>有 n 个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p><p>为方便讲解和理解，下面讲述的例子均先用具体的数字代入，即：eg：number＝4，capacity＝8</p><table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>i（物品编号）</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>w（体积）</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>v（价值）</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table>总体思路----<p>根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出 01 背包问题的最优解以及解组成，然后编写代码实现。</p><h3 id="动态规划的原理"><a href="#动态规划的原理" class="headerlink" title="动态规划的原理"></a>动态规划的原理</h3><p>动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，<strong>通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。</strong></p><p>最优性原理是动态规划的基础，最优性原理是指 “多阶段决策过程的最优决策序列具有这样的性质：<strong>不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略</strong>”。</p><h3 id="背包问题的解决过程"><a href="#背包问题的解决过程" class="headerlink" title="背包问题的解决过程"></a>背包问题的解决过程</h3><p>在解决问题之前，为描述方便，首先定义一些变量：<strong>Vi 表示第 i 个物品的价值，Wi 表示第 i 个物品的体积，定义 V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，</strong>同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取 0 或 1，表示第 i 个物品选或不选）。</p><p>1、建立模型，即求 max(V1X1+V2X2+…+VnXn)；</p><p>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；</p><p>3、<strong>寻找递推关系式</strong>，面对当前商品有两种可能性：</p><ul><li><strong>包的容量比该商品体积小，装不下，此时的价值与前 i-1 个的价值是一样的，即 V(i,j)=V(i-1,j)；</strong></li><li><strong>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即 V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。</strong></li></ul><p>其中 V(i-1,j) 表示不装，V(i-1,j-w(i))+v(i) 表示装了第 i 个商品，背包容量减少 w(i)，但价值增加了 v(i)；</p><p>由此可以得出递推关系式：</p><ul><li>j&lt;w(i)      V(i,j)=V(i-1,j)</li><li>j&gt;=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><p>这里需要解释一下，为什么能装的情况下，需要这样求解（这才是本问题的关键所在！）：</p><p><strong>可以这么理解，如果要到达 V(i,j) 这一个状态有几种方式？</strong></p><p><strong>肯定是两种，第一种是第 i 件商品没有装进去，第二种是第 i 件商品装进去了。</strong>没有装进去很好理解，就是 V(i-1,j)；装进去了怎么理解呢？如果装进去第 i 件商品，那么装入之前是什么状态，肯定是 V(i-1,j-w(i))。由于最优性原理（上文讲到），V(i-1,j-w(i)) 就是前面决策造成的一种状态，后面的决策就要构成最优策略。两种情况进行比较，得出最优。</p><p>4、填表，首先初始化边界条件，V(0,j)=V(i,0)=0；</p><p><a href="https://imgchr.com/i/NHqUN4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NHqUN4.png" alt="NHqUN4.png"></a></p><p>然后一行一行的填表：</p><ul><li>如，i=1，j=1，w(1)=2，v(1)=3，有 j&lt;w(1)，故 V(1,1)=V(1-1,1)=0；</li><li>又如 i=1，j=2，w(1)=2，v(1)=3，有 j=w(1), 故 V(1,2)=max｛ V(1-1,2)，V(1-1,2-w(1))+v(1) ｝=max｛0，0+3｝=3；</li><li>如此下去，填到最后一个，i=4，j=8，w(4)=5，v(4)=6，有 j&gt;w(4)，故 V(4,8)=max｛ V(4-1,8)，V(4-1,8-w(4))+v(4) ｝=max｛9，4+6｝=10……</li></ul><p>所以填完表如下图：</p><p><a href="https://imgchr.com/i/NHqNEF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NHqNEF.png" alt="NHqNEF.png"></a></p><p>5、表格填完，最优解即是 V(number,capacity)=V(4,8)=10。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了和之前的动态规划图可以进行对比，尽管只有 4 个商品，但是我们创建的数组元素由 5 个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> &#125;;<span class="comment">//商品的体积2、3、4、5</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> &#125;;<span class="comment">//商品的价值3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> bagV = <span class="number">8</span>;        <span class="comment">//背包大小</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;        <span class="comment">//动态规划表</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//动态规划表的输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题最优解回溯"><a href="#背包问题最优解回溯" class="headerlink" title="背包问题最优解回溯"></a>背包问题最优解回溯</h2><p>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，故要根据最优解回溯找出解的组成，根据填表的原理可以有如下的寻解方式：</p><ul><li><strong>V(i,j)=V(i-1,j) 时，说明没有选择第 i 个商品，则回到 V(i-1,j)；</strong></li><li><strong>V(i,j)=V(i-1,j-w(i))+v(i) 时，说明装了第 i 个商品，该商品是最优解组成的一部分，随后我们得回到装该商品之前，即回到 V(i-1,j-w(i))；</strong></li><li><strong>一直遍历到 i＝0 结束为止，所有解的组成都会找到。</strong></li></ul><p>就拿上面的例子来说吧：</p><ul><li>最优解为 V(4,8)=10，而 V(4,8)!=V(3,8) 却有 V(4,8)=V(3,8-w(4))+v(4)=V(3,3)+6=4+6=10，所以第 4 件商品被选中，并且回到 V(3,8-w(4))=V(3,3)；</li><li>有 V(3,3)=V(2,3)=4，所以第 3 件商品没被选择，回到 V(2,3)；</li><li>而 V(2,3)!=V(1,3) 却有 V(2,3)=V(1,3-w(2))+v(2)=V(1,0)+4=0+4=4，所以第 2 件商品被选中，并且回到 V(1,3-w(2))=V(1,0)；</li><li>有 V(1,0)=V(0,0)=0，所以第 1 件商品没被选择。</li></ul><p><a href="https://imgchr.com/i/NHqa4J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/02/NHqa4J.png" alt="NHqa4J.png"></a></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>背包问题最终版详细代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> w[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> &#125;;<span class="comment">//商品的体积2、3、4、5</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">5</span>] = &#123; <span class="number">0</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> &#125;;<span class="comment">//商品的价值3、4、5、6</span></span><br><span class="line"><span class="keyword">int</span> bagV = <span class="number">8</span>;        <span class="comment">//背包大小</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][<span class="number">9</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;        <span class="comment">//动态规划表</span></span><br><span class="line"><span class="keyword">int</span> item[<span class="number">5</span>];        <span class="comment">//最优解情况</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findMax</span><span class="params">()</span> </span>&#123;<span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bagV; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findWhat</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="comment">//最优解情况</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">item[i] = <span class="number">0</span>;</span><br><span class="line">findWhat(i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j - w[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i - <span class="number">1</span>][j - w[i]] + v[i]) &#123;</span><br><span class="line">item[i] = <span class="number">1</span>;</span><br><span class="line">findWhat(i - <span class="number">1</span>, j - w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;<span class="comment">//动态规划表输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)<span class="comment">//最优解输出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">findMax();</span><br><span class="line">findWhat(<span class="number">4</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp算法学习：最大子段和及LIS,LCS</title>
      <link href="/2020/07/01/dp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
      <url>/2020/07/01/dp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><p>最大子段的概念：连续的一段子序列称为一个子段，子段中所有数的和称为子段和。</p><p><strong>例题</strong>： </p><p>下列数列最大子段和为多少</p><p>-2，11，-4，13，-5，-2</p><a id="more"></a><h2 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h2><ol><li>枚举两个端点，遍历所选出的子段求和。枚举端点复杂度为<strong>O(n²)</strong>，求一个子段的和，复杂度为<strong>O(n)</strong>，因此最终复杂度为<strong>O(n³)</strong></li><li>求一个子段和可以预处理前缀和进行优化，将这一部分复杂度为<strong>O(1)</strong>，总时间复杂度降为<strong>O(n²)</strong></li></ol><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><p><strong>分析：</strong></p><ul><li>对于非正数的序列，其中的一个元素本身就是最大值。</li><li>对于有正数的序列，考虑以每一个点为结尾的最大子段和，这个子段一定满足其前缀和为非负，因为如果一个前缀是负，那么减掉这个前缀一定对于这个点更优，并且这个子段要尽量向前延伸</li></ul><p><strong>实现：</strong></p><ul><li><p>可以用一次扫描，记录目前统计的sum及答案ans。 当sum加上当前位置数如果还是正数的话就进行累加sum，否则将sum置为0. 这样就可以舍去所有前缀为负数的情况，并且保证这个子段尽可能地长，每一次sum如果比ans大的话就更新ans，这样就得到了最大子段和。</p></li><li><p>时间复杂度为O(n)</p></li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态规划，最大子段和*/</span></span><br><span class="line"><span class="comment">/*2020年7月1日 07:23:31*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf =<span class="number">0x7ffffff</span>; <span class="comment">//无穷大</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans= -inf; <span class="comment">//先标记ans为num数组中最大值,也就是负无穷。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>)&#123; <span class="comment">//最大值小于0则输出</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+num[i]&lt;<span class="number">0</span>)&#123; <span class="comment">//如果前缀和为负数，则将sum置为0，下一个元素本身就是最大</span></span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum +=num[i]; <span class="comment">//否则继续累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans =<span class="built_in">max</span>(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h1><p>在原序列取任意项，不改变原本的先后次序，得到原序列的子序列。最长子序列就是给定子序列中一个最长的、数值从低到高排序的子序列，同时最长子序列并不是唯一的。</p><p><strong>例题</strong>：</p><p>在序列5,2,7,9,4,5,7,10中最大上升子序列长度。</p><p><strong>分析</strong>：</p><ul><li>用dp[i]作为一定以第i项结尾的最长上升子序列。用a[i]表示第i项的值，如果有j&lt;i且a[j]&lt;a[i]，那么把第i项接到第j项后面构成子序列长度为dp[i]=dp[j]+1</li><li>要使dp[i]为以i结尾的最长上升子序列，需要枚举所有满足条件的j。所以状态转移方程为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; max(dp[i] , dp[j]+1), 1&lt;&#x3D;j&lt;i &amp;&amp; a[j]&lt;a[i]</span><br></pre></td></tr></table></figure><ul><li>最后，dp数组中最大值就是最大上升子序列的长度</li><li>时间复杂度O(n²)</li></ul><p>根据动态规划状态转移方程得到如下表格：<span class='p red'>（清晰明了，一看就懂！）</span></p><table><thead><tr><th align="center">i</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th></tr></thead><tbody><tr><td align="center">a[i]</td><td align="center">5</td><td align="center">2</td><td align="center">7</td><td align="center">9</td><td align="center">4</td><td align="center">5</td><td align="center">7</td><td align="center">10</td></tr><tr><td align="center">dp[i]</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td></tr></tbody></table><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态规划：最长上升子序列*/</span></span><br><span class="line"><span class="comment">/*2020年7月1日 07:53:44*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>],a[<span class="number">101</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]); <span class="comment">//ans记录当前位置的最大上升子序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;LIS()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h1><p><strong>例题：</strong>最长公共子序列：给定两个序列<strong>S1</strong>和<strong>S2</strong>，求两者的公共子序列<strong>S3</strong>的最长的长度</p><p><strong>分析</strong>：</p><ul><li><p>可以按照前面所学的，按照序列的长度来划分状态，也就是S1的前i个字符和S2的前j个字符的最长公共子序列长度，记为lcs [i] [j]</p></li><li><p>如果S1的第i项和S2的第j项相等，那么S1[i]和S2[j]作为公共子序列的末尾，则：</p><div class="note "><p>lcs[i] [j] = lcs[i-1] [j-1] +1</p></div></li><li><p>也可以不让S1[i]和S2[j]作为公共子序列的末尾，则:</p><p><strong>lcs[i] [j] = max(lcs[i] [j-1], lcs[i-1] [j])</strong></p></li></ul><p><strong>动态转移方程：</strong></p><p><img src="https://s1.ax1x.com/2020/07/01/Now9r4.png" alt="动态转移方程"></p><p><strong>举例理解：</strong></p><p>两个序列： <strong>S1=abcfbc</strong> ， <strong>S2=abfcab</strong> 根据状态方程可得如下表格：</p><table><thead><tr><th align="center">lcs</th><th align="center">0</th><th align="center">1(a)</th><th align="center">2(b)</th><th align="center">3(c)</th><th align="center">4(f)</th><th align="center">5(b)</th><th align="center">6(c)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1(a)</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2(b)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">3(f)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">4(c)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">5(a)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">6(b)</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">4</td><td align="center">4</td></tr></tbody></table><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> lena=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lenb=b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[lena][lenb]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp算法学习：连续子数组的最大和</title>
      <link href="/2020/06/30/dp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2020/06/30/dp%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h1><p>dp作为经典算法之一，必须要花大量时间去好好掌握。</p><a id="more"></a><h2 id="典型例题："><a href="#典型例题：" class="headerlink" title="典型例题："></a>典型例题：</h2><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><h2 id="动态规划解析："><a href="#动态规划解析：" class="headerlink" title="动态规划解析："></a>动态规划解析：</h2><ul><li><p><strong>状态定义</strong>：先设动态规划列表dp，dp[i]代表以元素nums[i]为结尾的连续子数组的最大和。</p><ul><li>最大和dp[i]中必须包含元素nums[i]:保证dp[i]递推到dp[i+1]的正确性，如果不包含nums[i]，递推时候就不满足连续<strong>子数组</strong>的要求。</li></ul></li><li><p><strong>转移方程</strong>：如果dp[i-1]&lt;=0,说明dp[i-1]对dp[i]产生负贡献，即dp[i-1]+nums[i]的值不如nums[i]本身大。</p><pre><code>- 当dp[i-1]&gt;0时：执行dp[i]=dp[i-1]+nums[i];  - 当dp[i-1]&lt;=0时：执行dp[i]=nums[i];</code></pre></li><li><p><strong>初始状态</strong>：dp[0]=nums[0],即以nums[0]结尾的连续子数组最大和为nums[0]</p></li><li><p><strong>返回值</strong>：返回dp列表中的最大值，代表全局最大值</p></li></ul><h2 id="过程图解："><a href="#过程图解：" class="headerlink" title="过程图解："></a>过程图解：</h2><p><a href="https://imgchr.com/i/NICB2d" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/30/NICB2d.md.png" alt="NICB2d.md.png"></a></p><p><a href="https://imgchr.com/i/NICyrt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/30/NICyrt.md.png" alt="NICyrt.md.png"></a></p><p>[<img src="https://s1.ax1x.com/2020/06/30/NICDxA.md.png" alt="NICDxA.md.png"><br><a href="https://imgchr.com/i/NICsKI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/30/NICsKI.md.png" alt="NICsKI.md.png"></a></p><h2 id="leetcode提交代码："><a href="#leetcode提交代码：" class="headerlink" title="leetcode提交代码："></a>leetcode提交代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*2020年6月30日 17:07:28*/</span></span><br><span class="line"><span class="comment">/*leetcode动态规划算法练习*/</span></span><br><span class="line"><span class="comment">/*剑指 Offer 42. 连续子数组的最大和*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(nums.<span class="built_in">size</span>(),nums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年6月总结</title>
      <link href="/2020/06/30/6%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/30/6%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>6月份应该来说是1月至今最忙碌的一个月。</p><a id="more"></a><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><h2 id="驾考"><a href="#驾考" class="headerlink" title="驾考"></a>驾考</h2><p>​       6月1日开始去练科二，6月10日科二过关，6月11日开始练科三，6月18日科目三过关，6月29日过关科目四，当场拿驾驶证。一个月没有停歇，但是很好地躲过了暑假的炎热天气~</p><img src="https://s1.ax1x.com/2020/06/30/N4Nwo8.md.jpg" alt="机动车驾驶证" style="zoom: 80%;" /><h2 id="学校课程实习："><a href="#学校课程实习：" class="headerlink" title="学校课程实习："></a>学校课程实习：</h2><p>​         忙着数据结构的任务同时，突然来了模电实验的课程要求，很是倒霉，算是应付过去了。但是暑假还是要好好把模电复习复习，说实话没怎么好好学啊，而且确实没有任何一丝兴趣。</p><h2 id="编程能力："><a href="#编程能力：" class="headerlink" title="编程能力："></a>编程能力：</h2><p>​        应该说在家至今自己刷的编程题目并不多，自己掌握的算法也不是很精，要想在9月下旬的蓝桥杯拿到去北京参赛的资格，还需要自己很大的努力了！！加油，奥利给！！</p><img src="https://s1.ax1x.com/2020/06/30/N4N4FU.jpg" style="zoom: 25%;" /><h2 id="暑假安排："><a href="#暑假安排：" class="headerlink" title="暑假安排："></a>暑假安排：</h2><p>​        原本想要找一份兼职，但是确实在本地很难找到一个自己满意的活干，还是算了，毕竟期末考试还没有考完，自己还是要抓紧时间复习好几门专业课知识点。同时自己暑假更多的时间打算安排学习C++，也要跟进自己算法的学习，每天坚持刷题了。 </p><p>​         还有值得注意的是，整个六月份自己体重的飙增，暑假控制饮食，多运动！！</p>]]></content>
      
      
      <categories>
          
          <category> 月总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驾考 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础与提高：Day2 引用</title>
      <link href="/2020/06/27/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day2%E5%BC%95%E7%94%A8/"/>
      <url>/2020/06/27/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day2%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>规则：</p><p>引用没有定义，是一种关系型声明。声明它和原有的某一变量的关系。故而类型与原类型保持一致，且不分配内存。与被引用的变量有相同的地址。</p><p>声明的时候必须初始化，一经声明，不可以更变。</p><a id="more"></a><p>可对引用，再次引用。多次引用的结果是某一变量具有多个别名。</p><p>&amp;符号前有数据类型时，是引用。其他皆为取地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"><span class="keyword">int</span> &amp;r = b;<span class="comment">//错误，不可以更改原有的引用关系</span></span><br><span class="line"><span class="keyword">float</span> &amp;rr = b; <span class="comment">//错误，引用类型不匹配。</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;&amp;r&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//变量与引用具有相同的地址。</span></span><br><span class="line"><span class="keyword">int</span> &amp;ra=r; <span class="comment">//可对引用更次引用，表示a变量有两个别名，分别是r和ra</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>​    c++很少使用独立变量的引用，如果使用某一个变量，就直接使用它的原名，没有必要去使用他的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用提高"><a href="#引用提高" class="headerlink" title="引用提高"></a>引用提高</h2><pre><code>1.  可以定义指针的引用，但不能定义引用的引用。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>*p = &amp;a;</span><br><span class="line"><span class="keyword">int</span>* &amp;rp =p; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rr =r; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *t;</span><br><span class="line">t = pa;</span><br><span class="line">pa = pb;</span><br><span class="line">pb = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">char</span> **pa,<span class="keyword">char</span> **pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *t;</span><br><span class="line">t = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">char</span> *&amp;pa,<span class="keyword">char</span> *&amp;pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *t;</span><br><span class="line">t = pa;</span><br><span class="line">pa = pb;</span><br><span class="line">pb = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pa =<span class="string">"china"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pb =<span class="string">"america"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pa"</span>&lt;&lt;pa&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pb"</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//swap(pa,pb);</span></span><br><span class="line"><span class="comment">//swap2(&amp;pa,&amp;pb);</span></span><br><span class="line">  swap3(pa,pb);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pa "</span>&lt;&lt;pa&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pb "</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以定义指针的指针，（即二级指针），但不能定义引用的指针。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **pp = &amp;p; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="keyword">int</span>&amp;* pr= &amp;r; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以定义指针数组，但不能定义引用数组，可以定义数组引用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">int</span>* parr[]=&#123;&amp;a,&amp;b,&amp;c&#125;; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; rarr[]=&#123;a,b,c&#125;: <span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;rarr)[<span class="number">3</span>] = arr; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>未完待续…… 2020年6月27日 23:06:47</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础与提高：Day1 C++对C的Externsion</title>
      <link href="/2020/06/26/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day1%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA/"/>
      <url>/2020/06/26/C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98Day1%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="类型增强"><a href="#类型增强" class="headerlink" title="类型增强"></a>类型增强</h1><h2 id="类型检查严格"><a href="#类型检查严格" class="headerlink" title="类型检查严格"></a>类型检查严格</h2><p>在c中存在一个const类型的指针赋值给非const类的指针，并且可以顺利通过，但是在c++中是无法通过的。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b=a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pa=&amp;a;</span><br><span class="line"><span class="keyword">int</span> *pb =pa;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag!=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i know bool type now\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bool size=%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>c中枚举本质就是整型，枚举变量可以用任意整型赋值，但是c++中枚举变量，只能用被枚举出来的元素进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">enum</span> season&#123;SPR,SUM,AUT,WIN&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> season s=SPR；</span><br><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式的值可以被赋值"><a href="#表达式的值可以被赋值" class="headerlink" title="表达式的值可以被赋值"></a>表达式的值可以被赋值</h2><p>c++中表达式是可以赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b=<span class="number">5</span>;</span><br><span class="line">(a=b)=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">(a&lt;b?a:b)=<span class="number">200</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="标准的输入输出"><a href="#标准的输入输出" class="headerlink" title="标准的输入输出"></a>标准的输入输出</h1><h2 id="设置域宽及位数"><a href="#设置域宽及位数" class="headerlink" title="设置域宽及位数"></a>设置域宽及位数</h2><p>对于实型，cout默认输出六位有效数据，setprecision(2)可以设置有效位数，setprecision(n)&lt;&lt;setiosflags(ios::fixed)合用，可以设置小数点右边的位数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c \n%d\n%f\n"</span>,<span class="string">'a'</span>,<span class="number">100</span>,<span class="number">120.00</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%5c\n%5d\n%6.2f\n"</span>,<span class="string">'a'</span>,<span class="number">100</span>,<span class="number">120.00</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">5</span>)&lt;&lt;<span class="string">'a'</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;setw(<span class="number">5</span>)&lt;&lt;<span class="number">100</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;<span class="number">120.00</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按进制输出"><a href="#按进制输出" class="headerlink" title="按进制输出"></a>按进制输出</h2><p>输出十进制，十六进制，八进制。默认输出十进制的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">123</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dec&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;oct&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setbase(<span class="number">6</span>)&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="设置填充符"><a href="#设置填充符" class="headerlink" title="设置填充符"></a>设置填充符</h2><p>还可以设置域宽的同时，设置左右对齐及填充字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;setiosflags(ios::left)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">'-'</span>)&lt;&lt;setiosflags(ios::right)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>c++致力于简化编程，能够通过函数重名来达到简化编程的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;<span class="number">0</span>? a:-a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;<span class="number">0</span>?a:-a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载规则与调用匹配"><a href="#重载规则与调用匹配" class="headerlink" title="重载规则与调用匹配"></a>重载规则与调用匹配</h2><p>重载规则：</p><ol><li>函数名相同。</li><li>参数个数不同，参数类型不同，参数顺序不同，均可构成重载。</li><li>返回值类型不同则不可以构成重载。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>; <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a)</span></span>; <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">int</span> b)</span></span>; <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b)</span></span>; <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>; <span class="comment">//与第一个函数有冲突</span></span><br></pre></td></tr></table></figure><p>★匹配原则：</p><ol><li>严格匹配，找到则调用。</li><li>通过隐式转换寻求一个匹配，找到则调用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>); <span class="comment">//print(int)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>,<span class="number">1</span>); <span class="comment">//print(double)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a'</span>); <span class="comment">//print(int)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.11f</span>);<span class="comment">//print(double)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>c++允许int到long和double，double到int和float隐式类型转换。</p><p>解决方法是在调用的时候就进行强转。</p><h2 id="重载底层实现"><a href="#重载底层实现" class="headerlink" title="重载底层实现"></a>重载底层实现</h2><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>name mangling 发生在两个阶段，.cpp编译阶段，和.h的声明阶段。</p><p>只有两个阶段同时进行，才能匹配调用。</p><p>c++完全兼容c语言，也就意味着完全兼容c的类库，由于.c文件的类库文件中函数名并没有发生name mangling行为，而我们在包含.c文件所对应的.h文件时，.h文件要发生name manling行为，因而会发生在链接的时候的错误。</p><p>c++为了避免上述的错误发生，重载了关键字extern。只需要在避免name manling的函数前，加上extern “C”</p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMP</span>&#123;</span></span><br><span class="line"><span class="keyword">float</span> real;</span><br><span class="line"><span class="keyword">float</span> <span class="built_in">image</span>;</span><br><span class="line">&#125;;</span><br><span class="line">COMP <span class="keyword">operator</span>+(COMP one,COMP another)</span><br><span class="line">&#123;</span><br><span class="line">one.real+ =another.real;</span><br><span class="line">one.<span class="built_in">image</span>+ =another.<span class="built_in">image</span>;</span><br><span class="line"><span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">COMP c1=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">COMP c2=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">COMP sum =<span class="keyword">operator</span>+(c1,c2); <span class="comment">//c1+c2;</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum.real&lt;&lt;<span class="string">" "</span>&lt;&lt;sum.<span class="built_in">image</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>通常情况下，函数在调用时，形参从实参那里取得值。对于多次调用函数同一个实参时，C++给出了更简单的处理办法。给形参以默认值，不用再从实参取值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weatherForcast</span><span class="params">(<span class="keyword">char</span> *w=<span class="string">"sunny"</span>)</span> <span class="comment">//给出默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">time_t</span> t=time(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">(<span class="keyword">float</span> length,<span class="keyword">float</span> weight=<span class="number">4</span>,<span class="keyword">float</span> high=<span class="number">5</span>)</span> <span class="comment">//从右往左，不能跳跃</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> length*weight*high;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> v=volume(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">float</span> v1=volume(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">float</span> v2=volume(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v1&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>默认从右往左，并且其中不能跳跃。</li><li>函数声明和定义一体时，默认参数在定义处。声明在前，定义在后，默认参数在声明处。</li><li>一个函数不能既作为重载，又作为默认参数的函数。当少写一个参数时，系统无法确认是重载还是默认参数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">110</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客算法：分治递归及C++中STL库</title>
      <link href="/2020/06/24/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/"/>
      <url>/2020/06/24/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>结合牛客算法课和c转c++教程，做出一些关于算法学习的总结。</p><h2 id="分治："><a href="#分治：" class="headerlink" title="分治："></a>分治：</h2><p>基本思想：求解某些问题时，直接求解的过程相当复杂，往往先把它分解成几个子问题，找到求出子问题的解法后，找到合适方法组合，求整个问题。</p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><p>本质：就是函数的不断调用“自身”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x*f(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型例题：汉诺塔问题</p><p><a href="https://imgchr.com/i/NdiGqO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdiGqO.md.png" alt="NdiGqO.md.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c -&gt;%c\n"</span>,A,C);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">hanoi(n<span class="number">-1</span>,A,C,B);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c -&gt;%c\n"</span>,B,A,C);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="倍增："><a href="#倍增：" class="headerlink" title="*倍增："></a>*倍增：</h3><p>从字面上看是成倍的增长。指我们在处理一个问题的时候，如果问题的规模很大，线性递推无法满足时间和空间复杂度的要求，就可以通过成倍的增长，先求解状态空间中在2的整数次幂位置上的值作为代表，再对答案进行求解拼接。</p><p><a href="https://imgchr.com/i/NdFtXV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/24/NdFtXV.md.png" alt="NdFtXV.md.png"></a></p><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h2 id="c-中STL库："><a href="#c-中STL库：" class="headerlink" title="c++中STL库："></a>c++中STL库：</h2><h3 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h3><p>最大值最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">Tp</span> <span class="title">min</span>(_<span class="title">Tp</span> <span class="title">a</span>,_<span class="title">Tp</span> <span class="title">b</span>);</span></span><br><span class="line"><span class="function">_Tp <span class="title">max</span><span class="params">(_Tp a,_Tp b)</span></span>;</span><br></pre></td></tr></table></figure><p>快速排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(a,a+<span class="number">10</span>); <span class="comment">//从a[0]到a[9]</span></span><br></pre></td></tr></table></figure><p>数据交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(a,b);</span><br></pre></td></tr></table></figure><p>求下一个排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next_permutation(a,a+n);</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><h4 id="动态数组vector-矢量"><a href="#动态数组vector-矢量" class="headerlink" title="动态数组vector(矢量)"></a>动态数组vector(矢量)</h4><p>相比于c中int arr[]定义数组的好处是能够在运行的阶段设置数组的长度、在末尾可以增加新的数据，在中间可以插入新的值，同时vector的长度可以任意被改变。</p><p>使用时需要引入头文件#include<vector>和using namespace std;</p><p>vector的大小用.size()获取，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1; <span class="comment">//定义一个vector v1,定义的时候并没有分配大小</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v1.<span class="built_in">size</span>(): <span class="comment">//输出vector v1的大小，此处应该为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector可以在一开始就不定义大小，之后用resize方法进行分配大小，也可以一开始就定义大小，之后可以对它插入删除动态改变它的大小。同时在全局中，默认所有值都为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//直接定义了长度为10的int数组，初始化直接默认这10个元素为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line">vecotr&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.resize(<span class="number">8</span>); <span class="comment">//先定义一个vector变量v1，然后先将长度resize为8，同时自动默认值都为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问vector时候，跟c中访问数组一样用[]下标访问即可.</span></span><br><span class="line">v[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>常用的vector使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a; <span class="comment">//定义的时候并没有指定vector大小</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 这个时候size为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        a.push_back(i); <span class="comment">//在vector a的末尾添加一个元素i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//此时会发现a的size变成了10</span></span><br><span class="line">    <span class="comment">//定义一个动态数组b</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;b(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        b[i]=<span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//定义一个vector大小为20，同时所有元素都赋值为2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;c(<span class="number">20</span>,<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.<span class="built_in">size</span>():i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//这里用迭代器的方式访问vector中每一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=c.<span class="built_in">begin</span>();it!=c.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h4 id="字符类string"><a href="#字符类string" class="headerlink" title="字符类string"></a>字符类string</h4><p>c中通常使用char[]处理字符串，而c++中运用string，但需要记住的是只能通过cin和cout处理，无法使用scanf和printf处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"hello world!"</span>; <span class="comment">//赋值字符串</span></span><br><span class="line"><span class="built_in">string</span> s2=s;</span><br><span class="line"><span class="built_in">string</span> s3=s+s2; <span class="comment">//字符串拼接用+号就可以</span></span><br><span class="line"><span class="built_in">string</span> s4;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s4; <span class="comment">//读入字符串</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s; <span class="comment">//输出字符串</span></span><br></pre></td></tr></table></figure><p>需要注意的是cin读入字符串的时候，是以空格为分隔符。如果想要读入整行的字符串，需要使用函数getline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s; <span class="comment">//定义一个空的字符串s</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s); <span class="comment">//读取一行的字符串，包括空格</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.length(); <span class="comment">//输出字符串s的长度</span></span><br><span class="line"><span class="comment">//常用截取某子串的函数substr</span></span><br><span class="line"><span class="built_in">string</span> s2=s.substr(<span class="number">4</span>); <span class="comment">//表示从下标4开始一直到结束</span></span><br><span class="line"><span class="built_in">string</span> s3=s.substr(<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//表示从下标为5开始，截取3个字符</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h4 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h4><p>set是一个集合，一个set里面的各元素并不相同，而且set会按照元素进行从小到大排序。</p><p>set常用用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namspace <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//定义一个空集合s</span></span><br><span class="line">    s.insert(<span class="number">1</span>); <span class="comment">//向集合s中插入一个1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;*(s.<span class="built_in">begin</span>()) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出集合s的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        s.insert(i); <span class="comment">//向集合s里面插入i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用迭代器遍历集合s里面的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it =s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;(s.<span class="built_in">find</span>(<span class="number">2</span>)!=s.<span class="built_in">end</span>())&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查找集合s中值,如果结果等于s.end()表示未找到</span></span><br><span class="line">    <span class="comment">//★需要特别注意的是，s.end()表示s的最后一个元素的下一个元素所在的位置</span></span><br><span class="line">    <span class="built_in">cout</span>&gt;&gt;(s.<span class="built_in">find</span>(<span class="number">10</span>)!=s.<span class="built_in">end</span>())&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//s.find(10)!=s.end()表示能找到10这个元素</span></span><br><span class="line">    s.erase(<span class="number">1</span>); <span class="comment">//删除集合s中的1这个元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(s.<span class="built_in">find</span>(<span class="number">1</span>)!=s.<span class="built_in">end</span>())&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 并没有任何东西输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/06/24/NdFHjP.jpg" alt=""></p><h4 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h4><p>map是键值对，一个人的名字对应着一个学号，可以定义为string类的人名为“键”，学号int类型为“值”，</p><p>如map&lt;string,int&gt;m;    map会自动将所有的键值对按照键从小到大排序，map使用时的头文件#include<map></p><p>map常用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m; <span class="comment">//定义一个空的map m,键是string类型，值是int类型</span></span><br><span class="line">    m[<span class="string">"hello"</span>]=<span class="number">2</span>; <span class="comment">//将key为“hello”，value为2的键值对存入map中</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; m[<span class="string">"hello"</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//访问map中key为“hello”的value，如果不存在，则返回0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; m[<span class="string">"world"</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    m[<span class="string">"world"</span>]=<span class="number">3</span>; <span class="comment">//将“world”键对应的值修改成3</span></span><br><span class="line">    m[<span class="string">","</span>]=<span class="number">1</span>; <span class="comment">//设立一组键值对，键为“,”，值为1</span></span><br><span class="line">   <span class="comment">//使用迭代器遍历，输出map中所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问map的第一个元素，输出键值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.<span class="built_in">begin</span>()-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;m.<span class="built_in">begin</span>()-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//访问map的最后一个元素，输出键值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.rbegin()-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;m.rbegin()-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出map的元素个数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C用scanf连续输入字符型数据常见问题</title>
      <link href="/2020/06/15/c%20%E8%AF%AD%E8%A8%80%E7%94%A8%20scanf%20%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/15/c%20%E8%AF%AD%E8%A8%80%E7%94%A8%20scanf%20%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="C-用-scanf-连续输入字符型数据常见问题"><a href="#C-用-scanf-连续输入字符型数据常见问题" class="headerlink" title="C 用 scanf 连续输入字符型数据常见问题"></a>C 用 scanf 连续输入字符型数据常见问题</h1><p>在设计数据结构实习过程中遇到，连续输入字符的问题。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> i,j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in i:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i=%c\n"</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in j:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"j=%c\n"</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一个程序，看起来应该没有问题，运行结果理论上应该像这样：<br><img src="https://img-blog.csdn.net/20170423181627802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzgwNTI5OTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>但是实际上是这样：<br><img src="https://img-blog.csdn.net/20170423181735879?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzgwNTI5OTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>其中的原因就在于 scanf 是从标准缓冲区中读取输入的字符的，所以想上面那样写的时候字符型变量 j 接收的就是输入 i 之后输入的那个回车键。</p><p>解决方法：   </p><ol><li>用 fflush(stdin); 语句来清空缓冲区<br>代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> i,j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in i:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i=%c\n"</span>,i);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in j:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"j=%c\n"</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以得到想要的结果了。</p><ol start="2"><li>在 scanf(“%c”,&amp;j); 中的 %c 之前加个空格 -&gt;scanf(” %c”,&amp;j); 这样这个空格就可以抵消那个回车。</li></ol><p>实际上这种情况通常会出现在定义了一个字符型数据（eg.char flag;）然后在一个 for 或者 while 循环里面会多次输入这个 flag<br>eg.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag;</span><br><span class="line">    <span class="keyword">int</span> i,num[maxsize];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入数字:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"是否继续输入,如果是就输入y,反之输入n:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;flag);</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="string">'n'</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序是会出现这样的情况：<br><img src="https://img-blog.csdn.net/20170423183527232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzgwNTI5OTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>此时就可以使用上述两个方法解决。</p><p>例外，在使用 getchar() 输入字符的时候也会出现上述情况，此时除了可以用上述中方法一解决之外，对应上述的方法二可以可以改为：写两个 getchar();<br>eg.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> i,j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in i:"</span>);</span><br><span class="line">    i=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i=%c\n"</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"put in j:"</span>);</span><br><span class="line">    j=getchar();</span><br><span class="line">    j=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"j=%c\n"</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的原理与上述方法二是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驾考科目三要点(已过)</title>
      <link href="/2020/06/10/%E7%A7%91%E4%B8%89%E8%A6%81%E7%82%B9/"/>
      <url>/2020/06/10/%E7%A7%91%E4%B8%89%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>​    科目二10号下午过关，考试过程备受煎熬！！</p><p>​    现在认真准备18号的科三考试，暑假争取拿驾照！！！</p><div class="note red"><p>18号科目三已过关，29号科四，6月底拿驾照！</p></div><a id="more"></a><h1 id="科三灯光口诀"><a href="#科三灯光口诀" class="headerlink" title="科三灯光口诀"></a>科三灯光口诀</h1> <div class="note success"><p>直行跟车有路灯，全部使用近光灯。 <br/> 照明不良没路灯，前照变成远光灯。<br/> 只有通过和超越，交替使用远近光。<br/> 路边临停有故障，示廓加上双闪灯。 <br/></p></div><h2 id="科三注意点"><a href="#科三注意点" class="headerlink" title="科三注意点"></a>科三注意点</h2><ol><li><p>起步时候注意按喇叭，同时离合器要缓慢抬动，走出几米之后，再慢慢完全松掉离合器。</p></li><li><p>在变更车道，超车，打开转向灯后，3秒后点一脚油门，5秒钟之后，观察后视镜，变更车道，记得关闭转向灯，重打轻回！</p></li><li><p>路口转弯，要在通过人行横道后再端方向盘，并且在实线前要点2脚以上的刹车。 轻点。</p></li><li><p>紧急刹车，一脚踩死离合器，慢慢踩刹车，立即换成一档起步。</p></li><li><p>转弯都用二挡，听到语音播报，先打灯，后换挡，点刹两次后，观察后视镜，打死方向盘。</p></li><li><p>靠边停车，注意要先打灯，换成二挡，点刹两次，慢慢回正方向盘，踩死离合器和刹车，对准小白点，停车。 拉手刹，置空档，观察后视镜，按步骤离开驾驶座位。</p></li><li><p>三档要时刻保持25码的速度，记得多瞥一眼。尤其是变更车道，记得稍微带一点油门。</p></li><li><p>百米加减档，掉头后，迅速升到25码换成三档，立即加速到35码，等待语音播报，换成四档，数3秒后换成三档，同时注意保持25码速度行驶。3-4秒后换成二挡。 行驶一段距离，加速换成三档。<br> 直行通过路口，近光灯。</p></li><li><p>遇到任何状况，超车和变更车道有问题，包括档位不知道在几档都要立即停车 停车立刻挂一档  重新起步，记得打方向灯。</p></li><li><p>在变更车道，超车前，1234加油门 5秒移动方向盘。<br> 车正后再打方向灯。</p></li><li><p>通过学校区域，公交车站牌，时速保持20-25 一定要小25码 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驾考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驾考科目二要点(已过)</title>
      <link href="/2020/05/31/%E9%A9%BE%E8%80%83%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%A6%81%E7%82%B9/"/>
      <url>/2020/05/31/%E9%A9%BE%E8%80%83%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>原来二月份要考的科目二，好久没练车，忘得一干二净……别躺了，6月份开始继续练车。</p><a id="more"></a><p><a href=""><img src="https://s1.ax1x.com/2020/06/01/t8QdUK.md.jpg" alt="t8QdUK.md.jpg"></a></p><h1 id="考前准备："><a href="#考前准备：" class="headerlink" title="考前准备："></a>考前准备：</h1><ol><li>调整座椅，离合器踩到底</li><li>后视镜调整：左边能看到后轮（后视镜1/3） 右边压在后门把手 看到</li><li>安全带系好，确保不会弹出</li><li>检查仪表板</li><li><span class='p green'>拉手刹测试</span></li></ol><h1 id="倒车入库："><a href="#倒车入库：" class="headerlink" title="倒车入库："></a>倒车入库：</h1><ol><li>保持1.5米边距的方法：<span class='p blue'>左后视镜下沿一半的位置贴着线</span></li></ol><h1 id="曲线行驶："><a href="#曲线行驶：" class="headerlink" title="曲线行驶："></a>曲线行驶：</h1><ol><li><span class='p red'>打一圈</span>方向，左车角碰线回正，到右边角再打一圈方向，要出口时候<span class='p red'>稍微往左边回一些方向</span>。</li></ol><h1 id="侧方位停车："><a href="#侧方位停车：" class="headerlink" title="侧方位停车："></a>侧方位停车：</h1><ol><li>出库时候 先打左灯 车头一般盖线一般后回正，慢慢打一圈。</li><li>右边1/3盖到线大概是<span class='p yellow'>30公分！</span></li></ol><h1 id="直角转弯："><a href="#直角转弯：" class="headerlink" title="直角转弯："></a>直角转弯：</h1><ol><li>左侧雨刮器最高点贴右边线行驶 30公分 左门把手对齐直角。</li></ol><h1 id="坡道定点起步："><a href="#坡道定点起步：" class="headerlink" title="坡道定点起步："></a>坡道定点起步：</h1><ol><li>顶点记得挂空挡。</li><li>左后视镜下沿要对齐第二根实线。</li></ol><hr><div class="note "><p>大一暑假练车计划：</p></div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>六月一日开始练车。</p>            </div><div class='checkbox green'><input type="checkbox" />            <p>暑假至少考完科目二，练熟科目三。</p>            </div><div class='checkbox plus red checked'><input type="checkbox" checked="checked"/>            <p>变黑警告</p>            </div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         echo <span class="string">"这是一个日后生活的基本技能"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br></pre></td></tr></table></figure><h4 id="六月一日："><a href="#六月一日：" class="headerlink" title="六月一日："></a>六月一日：</h4><p>​    今天刚去第一天，预约10号考试，简单练了一下全程，<span class='p red'>坡道定点和曲线行驶点位看不见</span>。这天气是真热！</p><p><a href="https://imgchr.com/i/t8QvPU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/01/t8QvPU.md.jpg" alt="t8QvPU.md.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 考证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驾考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+hexo博客搭建</title>
      <link href="/2020/05/31/Github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/05/31/Github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>hexo静态博客搭建</p><a id="more"></a><p>耗费一晚上加一天时间算是搭建好了hexo博客，过程中也遇到很多问题。<br>好在有CSDN的大佬们的文章帮忙。希望能够持续更新博客哦！</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590925784787&di=98a3f4f5db31305086a77e55a80583f2&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20190208%2Fca63616f00fa419bbd79ef032cd07dfe.jpeg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
