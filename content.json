{"meta":{"title":"Zhenyu's Blog | 生活值得被记录.","subtitle":"","description":"","author":"zhenyu","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-31T08:02:51.987Z","updated":"2020-05-31T08:02:51.987Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-31T09:56:09.237Z","updated":"2020-05-31T09:56:09.237Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"计算机专业本科在校生，编程菜鸡一枚，小站刚刚创建，欢迎大佬指教！~"},{"title":"所有标签","date":"2020-05-31T08:55:40.192Z","updated":"2020-05-31T08:55:40.192Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not  Found","date":"2020-05-31T13:47:33.701Z","updated":"2020-05-31T13:47:33.701Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"C用scanf连续输入字符型数据常见问题","slug":"c 语言用 scanf 连续输入字符型数据常见问题","date":"2020-06-15T09:02:28.333Z","updated":"2020-06-15T09:11:55.433Z","comments":true,"path":"2020/06/15/c 语言用 scanf 连续输入字符型数据常见问题/","link":"","permalink":"http://yoursite.com/2020/06/15/c%20%E8%AF%AD%E8%A8%80%E7%94%A8%20scanf%20%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"C 用 scanf 连续输入字符型数据常见问题在设计数据结构实习过程中遇到，连续输入字符的问题。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char i,j; printf(\"put in i:\"); scanf(\"%c\",&amp;i); printf(\"i=%c\\n\",i); printf(\"put in j:\"); scanf(\"%c\",&amp;j); printf(\"j=%c\\n\",j); return 0;&#125; 很简单的一个程序，看起来应该没有问题，运行结果理论上应该像这样：但是实际上是这样： 其中的原因就在于 scanf 是从标准缓冲区中读取输入的字符的，所以想上面那样写的时候字符型变量 j 接收的就是输入 i 之后输入的那个回车键。 解决方法： 用 fflush(stdin); 语句来清空缓冲区代码： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char i,j; printf(\"put in i:\"); scanf(\"%c\",&amp;i); printf(\"i=%c\\n\",i); fflush(stdin); printf(\"put in j:\"); scanf(\"%c\",&amp;j); printf(\"j=%c\\n\",j); return 0;&#125; 这样就可以得到想要的结果了。 在 scanf(“%c”,&amp;j); 中的 %c 之前加个空格 -&gt;scanf(” %c”,&amp;j); 这样这个空格就可以抵消那个回车。 实际上这种情况通常会出现在定义了一个字符型数据（eg.char flag;）然后在一个 for 或者 while 循环里面会多次输入这个 flageg. 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxsize 10int main()&#123; char flag; int i,num[maxsize]; for(i=0;;i++) &#123; printf(\"请输入数字:\"); scanf(\"%d\",&amp;num[i]); printf(\"是否继续输入,如果是就输入y,反之输入n:\\n\"); scanf(\"%c\",&amp;flag); if(flag=='n') break; &#125; return 0;&#125; 运行程序是会出现这样的情况：此时就可以使用上述两个方法解决。 例外，在使用 getchar() 输入字符的时候也会出现上述情况，此时除了可以用上述中方法一解决之外，对应上述的方法二可以可以改为：写两个 getchar();eg. 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char i,j; printf(\"put in i:\"); i=getchar(); printf(\"i=%c\\n\",i); printf(\"put in j:\"); j=getchar(); j=getchar(); printf(\"j=%c\\n\",j); return 0;&#125; 这个方法的原理与上述方法二是一样的。","categories":[{"name":"编程困惑","slug":"编程困惑","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9B%B0%E6%83%91/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"驾考科目三要点","slug":"科三要点","date":"2020-06-10T08:13:39.156Z","updated":"2020-06-13T05:35:58.978Z","comments":true,"path":"2020/06/10/科三要点/","link":"","permalink":"http://yoursite.com/2020/06/10/%E7%A7%91%E4%B8%89%E8%A6%81%E7%82%B9/","excerpt":"","text":"​ 科目二10号下午过关，考试过程备受煎熬！！ ​ 现在认真准备18号的科三考试，暑假争取拿驾照！！！ 科三灯光口诀 直行跟车有路灯，全部使用近光灯。 照明不良没路灯，前照变成远光灯。 只有通过和超越，交替使用远近光。 路边临停有故障，示廓加上双闪灯。 科三注意点 起步时候注意按喇叭，同时离合器要缓慢抬动，走出几米之后，再慢慢完全松掉离合器。 在变更车道，超车，打开转向灯后，3秒后点一脚油门，5秒钟之后，观察后视镜，变更车道，记得关闭转向灯，重打轻回！ 路口转弯，要在通过人行横道后再端方向盘，并且在实线前要点2脚以上的刹车。 轻点。 紧急刹车，一脚踩死离合器，慢慢踩刹车，立即换成一档起步。 转弯都用二挡，听到语音播报，先打灯，后换挡，点刹两次后，观察后视镜，打死方向盘。 靠边停车，注意要先打灯，换成二挡，点刹两次，慢慢回正方向盘，踩死离合器和刹车，对准小白点，停车。 拉手刹，置空档，观察后视镜，按步骤离开驾驶座位。 三档要时刻保持25码的速度，记得多瞥一眼。尤其是变更车道，记得稍微带一点油门。 百米加减档，掉头后，迅速升到25码换成三档，立即加速到35码，等待语音播报，换成四档，数3秒后换成三档，同时注意保持25码速度行驶。3-4秒后换成二挡。 行驶一段距离，加速换成三档。 直行通过路口，近光灯。 遇到任何状况，超车和变更车道有问题，包括档位不知道在几档都要立即停车 停车立刻挂一档 重新起步，记得打方向灯。 在变更车道，超车前，1234加油门 5秒移动方向盘。 车正后再打方向灯。 通过学校区域，公交车站牌，时速保持20-25 一定要小25码","categories":[{"name":"考证","slug":"考证","permalink":"http://yoursite.com/categories/%E8%80%83%E8%AF%81/"}],"tags":[{"name":"驾考","slug":"驾考","permalink":"http://yoursite.com/tags/%E9%A9%BE%E8%80%83/"}]},{"title":"一元多项式","slug":"一元多项式","date":"2020-06-08T14:38:33.954Z","updated":"2020-06-08T14:38:14.024Z","comments":true,"path":"2020/06/08/一元多项式/","link":"","permalink":"http://yoursite.com/2020/06/08/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F/","excerpt":"","text":"一元多项式计算（C 语言） 题目： 一元多项式计算 功能要求： （1）能够按照指数降序排列建立并输出多项式； （2）能够完成两个多项式的相加、相减，并将结果输出； 程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define NULL 0typedef struct term &#123; float base; //底数 int expn; //指数 struct term *next;&#125;term, *LinkList;//term为一个新类型（是一个结构体），LinkList为指向这样的结构体的指针 typedef LinkList polynomial; //若有序链表L中存在与项t的指数相等的元素，则指针q指向L中第一个指数为t-&gt;expn的节点的位置，//否则q指向第一个指数满足与t-&gt;expn相比&gt;0的节点的前驱位置bool locateElem(LinkList L, LinkList t, LinkList &amp;q) &#123; LinkList p1 = L-&gt;next; LinkList p2 = L;//p2总指向p1的前驱 while (p1) &#123; if (t-&gt;expn &lt; p1-&gt;expn) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; else if (t-&gt;expn == p1-&gt;expn) &#123; q = p1; return true; &#125; else &#123;//p1-&gt;expn &gt; t-&gt;expn,因为L是有序表，所以如果程序走到了这一步，说明没找到与项t的指数相等的节点元素 //则返回q的前驱结点 q = p2; return false; &#125; &#125; if (!p1) &#123;//t-&gt;expn比当前列表所有元素的指数都大，则上面的while循环会因为p2到达了尾节点，p1=NULL而跳出 q = p2; return false; &#125;&#125; // 1. 直接选择排序 ------直接交换数据void ListSort_1(LinkList head)&#123; LinkList p = NULL; LinkList q = NULL; LinkList t = NULL; if (head == NULL || (head)-&gt;next == NULL) &#123; return; &#125; for (p = head; p != NULL; p = p-&gt;next) &#123; t = p; for (q = p-&gt;next; q != NULL; q = q-&gt;next) &#123; if (q-&gt;expn &gt; t-&gt;expn) &#123; t = q; &#125; &#125; if (t != p) &#123; LinkList tmp = NULL; tmp = p; p = t; t = tmp; &#125; &#125; return;&#125; //输入m项的系数和指数，建立表示一元多项式的带有头节点的有序链表P//利用尾插法void createPolyn(polynomial &amp;P, int m) &#123; //先建立一个带有头节点的空链表，即初始化 P = (polynomial)malloc(sizeof(term)); P-&gt;next = NULL; LinkList r = P;//r指针总是指向当前线性表的最后一个元素，即尾元素 printf(\"输入系数,指数,如项2x^5则输入(2,5):\\n\");//不必按升幂输入 for (int i = 0; i &lt; m; i++) &#123;//依次输入m个非零项 LinkList t = (LinkList)malloc(sizeof(term)); t-&gt;next = NULL; LinkList q; scanf(\"%f,%d\", &amp;t-&gt;base, &amp;t-&gt;expn); char c = getchar(); if (!locateElem(P, t, q)) &#123;//当前链表中不存在该指数项，则插入，此时q为链表中第一个指数&gt;t-&gt;expn的节点的前驱结点 t-&gt;next = q-&gt;next; q-&gt;next = t; &#125; else &#123;//当前列表中已经存在有节点元素的指数与本次输入的项的指数相同，所以本次输入无效，应重新输入 i--; &#125; &#125; ListSort_1(P);&#125; //打印多项式链表void printPolynomial(polynomial P) &#123; LinkList q = P-&gt;next; printf(\"打印多项式的线性表：[\"); while (q) &#123; printf(\"(%.2f,%d) \", q-&gt;base, q-&gt;expn); q = q-&gt;next; &#125; printf(\"]\\n\\n\");&#125; void display(polynomial L) //打印多项式&#123; polynomial p; p = L-&gt;next; printf(\"%.0fx^(%d)\", p-&gt;base, p-&gt;expn); p = p-&gt;next; while (p != NULL) &#123; if (p-&gt;base &gt; 0) &#123; printf(\"+%.0fx^(%d)\", p-&gt;base, p-&gt;expn); &#125; else &#123; printf(\"%.0fx^(%d)\", p-&gt;base, p-&gt;expn); &#125; p = p-&gt;next; &#125; printf(\"\\n\");&#125; int cmp(LinkList qa, LinkList qb) &#123;//比较项的指数大小 if (qa-&gt;expn &gt; qb-&gt;expn) return 1; else if (qa-&gt;expn == qb-&gt;expn) return 0; else return -1;&#125; void addPolyn(LinkList La, LinkList Lb, LinkList &amp;Lc)&#123; LinkList pa, pb, pc; pc = (LinkList)malloc(sizeof(term)); Lc = pc; pa = La-&gt;next; float x; pb = Lb-&gt;next; while (pb) &#123; if (!pa) &#123; break; &#125; if (pa-&gt;expn == pb-&gt;expn) //指数相同 &#123; //EXPN=pa-&gt;expn; x = pa-&gt;base + pb-&gt;base; if (x) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = x; pc-&gt;expn = pa-&gt;expn; &#125; pa = pa-&gt;next; pb = pb-&gt;next; continue; &#125; else if (pa-&gt;expn &gt; pb-&gt;expn) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = pa-&gt;base; pc-&gt;expn = pa-&gt;expn; pa = pa-&gt;next; continue; &#125; else if (pa-&gt;expn &lt; pb-&gt;expn) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = pb-&gt;base; pc-&gt;expn = pb-&gt;expn; pb = pb-&gt;next; continue; &#125; &#125; pc-&gt;next = NULL;&#125; void subPolyn(LinkList La, LinkList Lb, LinkList &amp;Lc)&#123; LinkList pa, pb, pc; pc = (LinkList)malloc(sizeof(term)); Lc = pc; pa = La-&gt;next; float x; pb = Lb-&gt;next; while (pb) &#123; if (!pa) &#123; break; &#125; if (pa-&gt;expn == pb-&gt;expn) //指数相同 &#123; //EXPN=pa-&gt;expn; x = pa-&gt;base - pb-&gt;base; if (x) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = x; pc-&gt;expn = pa-&gt;expn; &#125; pa = pa-&gt;next; pb = pb-&gt;next; continue; &#125; else if (pa-&gt;expn &gt; pb-&gt;expn) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = pa-&gt;base; pc-&gt;expn = pa-&gt;expn; pa = pa-&gt;next; continue; &#125; else if (pa-&gt;expn &lt; pb-&gt;expn) &#123; pc-&gt;next = (LinkList)malloc(sizeof(term)); pc = pc-&gt;next; pc-&gt;base = pb-&gt;base; pc-&gt;expn = pb-&gt;expn; pb = pb-&gt;next; continue; &#125; &#125; pc-&gt;next = NULL;&#125; int main() &#123; polynomial Pa,Pb,Pc,Pd; createPolyn(Pa, 5);//初始化并创建多项式链表Pa createPolyn(Pb, 3);//初始化并创建多项式链表Pb display(Pa); display(Pb); printf(\"执行多项式相加以后\\n\"); addPolyn(Pa, Pb, Pc); display(Pc); printf(\"执行多项式相减以后\\n\"); subPolyn(Pa, Pb, Pd); display(Pd); return 0;&#125; 参考资源： https://blog.csdn.net/qq_37623612/article/details/80312121 https://blog.csdn.net/c0ldHEart/article/details/83412436 https://blog.csdn.net/u010366748/article/details/50636748","categories":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"纸牌游戏","slug":"纸牌游戏","date":"2020-06-08T13:50:07.051Z","updated":"2020-06-08T13:50:07.051Z","comments":true,"path":"2020/06/08/纸牌游戏/","link":"","permalink":"http://yoursite.com/2020/06/08/%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F/","excerpt":"","text":"[题目]：编号为1-52张牌，正面向上，从第2张开始，以2为基数，是2的倍数的牌翻一次，直到最后一张牌；然后，从第3张开始，以3为基数，是3的倍数的牌翻一次，直到最后一张牌；然后从第4张开始，以4为基数，是4的倍数的牌翻一次，直到最后一张牌；……直到以52为基数的牌翻过，这时正面向上的牌有哪些？请设计算法编写程序输出最终正面向上的纸牌的编号。 [代码设计]： 123456789101112131415161718192021#include &lt;stdio.h&gt;#define N 52int main()&#123; int i,j; int card[N] = &#123;0&#125;; for (i = 2;i &lt;= N;i++) for (j = 2;j &lt;= N;j++) if (i % j == 0) &#123; if (card[i-1]) card[i-1] = 0; else card[i-1] = 1; &#125; printf(\"最后正面向上的扑克牌为:\\n\"); for (i = 0;i &lt; N;i++) if (card[i]==0) printf(\"第%d张\\n\",i + 1); printf(\"\\n\"); return 0;&#125;","categories":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构实习计划表","slug":"数据结构实习内容","date":"2020-06-08T12:00:15.047Z","updated":"2020-06-08T12:04:00.184Z","comments":true,"path":"2020/06/08/数据结构实习内容/","link":"","permalink":"http://yoursite.com/2020/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9/","excerpt":"","text":"数据结构实习计划表：","categories":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"科目二考试全过程（转）","slug":"科目二考试全流程详解","date":"2020-06-04T12:43:25.653Z","updated":"2020-06-04T12:48:38.262Z","comments":true,"path":"2020/06/04/科目二考试全流程详解/","link":"","permalink":"http://yoursite.com/2020/06/04/%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%80%83%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/","excerpt":"[TOC] “三字诀”：慢、稳、准慢：速度要慢，慢是完成一系列操作的基础，只有慢一点才能给你足够的反应时间。 稳：心态平和，不紧张，不慌乱；操控要稳。 准：看准点位，把握好火候，方向盘要打准。","text":"[TOC] “三字诀”：慢、稳、准慢：速度要慢，慢是完成一系列操作的基础，只有慢一点才能给你足够的反应时间。 稳：心态平和，不紧张，不慌乱；操控要稳。 准：看准点位，把握好火候，方向盘要打准。 一、上车准备（按顺序依次进行） 上车检查。方向盘和车轮要回正。方向盘始终在最上面卡紧。 调整座椅。靠背最大幅度往前靠至 90 度；左脚伸至离合器下侧，膝盖弯曲略大于 90 度，便于轻松用力。 调后视镜。左侧要看到左后轮接触地面；右侧看右前门把手在镜子中间。 系安全带。不要忘了或者插到副驾驶座，否则考试直接挂。按左手大拇指指纹。 打左转向灯。若忘了，就挂了。 车辆起步。踩离合、踩刹车，挂一档、松刹车、放手刹，轻抬离合，车辆启动。 二、牵线倒库牵线（若在 2 车道，在此基础上还要多牵 2 步） 点位 1：当肩膀与黄线平行时，方向盘向左一圈半 “打死”，车辆开始左转，目光正视前方，修正方向盘，直到方向盘左边最小铆钉正对着前方第三条黄色虚线的左边缘，左后视镜的中间部分压住左侧黄线为止。注意：中途不允许停车，否则直接挂科。 点位 2：车辆保持直行，当肩膀与地面黄色虚线平行时，离合、刹车 “双踩”，然后准备右倒库 三、倒车入库 右倒库（4 个点位） 点位 1：车辆开始后退，用余光观察左后视镜，当左后视镜与车身相交的夹角点即将抵达黄虚线上沿约 3～4 厘米处时，迅速向右一圈半打死，车辆开始向右侧后退 点位 2：低头弯腰，看左后视镜，当看见左侧车尾与左后方黄线直角之间的间距约 5 厘米左右时（实际有一咔长），方向盘迅速向左回半圈，车辆继续后退，开始入库 点位 3：继续低头弯腰，观察左后视镜，当看见车辆左侧车尾与左侧黄线平行时，方向盘迅速向左回一圈，此时方向盘已正，车辆后半部分已入库 点位 4：车辆继续后退，身体坐正，头朝前，用眼睛余光观察左后视镜与车身相交的夹角，当夹角的点落在左侧前方黄虚线的中间偏下一点时，“双踩死”，准备开始向左出库 左倒库（8 个点位） 起步准备：挂前进档一档，松刹车，缓慢抬离合，车辆开始向前直行，车头开始出库 点位 1：此点位与右倒库一致，特别注意方向盘不要打反。即：观察左后视镜，当看见左后轮越过黄色直角时，方向盘迅速向左一圈半打死 点位 2：车辆开始偏左前行，身体坐正，头看前方，用眼睛余光观察左后视镜的左边沿与左前方第二条黄虚线的右边沿基本重合时，方向盘向右回半圈 点位 3：车辆继续偏左缓慢行驶，头偏向左侧观察，当整个左车窗玻璃缝与左侧黄线平行时，方向盘迅速向右回一圈，此时方向盘已回正 点位 4：车辆继续前行，用眼镜余光观察，当自己的肩膀越过黄虚线时，“双踩死”，挂后档，松刹车，缓抬离合 点位 5：车辆开始后退，继续用余光观察左后视镜，当左后视镜与车身相交的夹角点即将抵达黄虚线上沿约 5～6 厘米处时，迅速向左一圈半打死，车辆开始向左侧后退 点位 6：低头弯腰，看右后视镜，当看见右侧车尾与右后方黄线直角之间的间距约 5 厘米左右时（实际有一咔长），迅速向右回半圈，车辆继续后退，开始入库 点位 7：继续低头弯腰，观察右后视镜，当看见车辆右侧车身与右侧黄线平行时，方向盘迅速向右回一圈，此时方向盘已正，车辆后半部分已入库 点位 8：车辆继续后退，身体坐正，头朝前，用眼睛余光观察左后视镜与车身相交的夹角，当夹角的点落在左侧前方黄虚线的中间偏下一点时，“双踩死”，准备开始向右出库 我倒了个标库 四、侧方停车（7 个点位）点位 1：车辆出库，观察左后轮越过黄色直角时，方向盘迅速向右打死 点位 2：当车辆右雨刮器上的 “三角背” 凸点略高于右侧墙砖上沿时，方向盘向左微调，直到左雨刮器中间缺口与黄线内侧相切，此时方向盘应该是正的。适当修正方向盘，让车辆沿着右侧黄线保持直线行驶。此时车身与右侧黄线不能小于 15 厘米大于 50 厘米 点位 3：观察右后视镜，当右侧黄色直角位于右后视镜中 2/3 处（右上角）时，“双踩”（此时车尾距离直角应该在 1 米以上，如果距离过短，与黄线平行，则直接挂科），挂倒挡，松刹车，轻抬离合，车辆开始后退 点位 4：当右后视镜中的直角接近消失时，方向盘向右打死，低头弯腰，看左后侧墙砖，到第四块砖露出 10-15 厘米左右时，方向盘迅速向左回正，车辆开始进库 点位 5：观察左后视镜，当看到左后轮即将压左侧黄虚线时，方向盘迅速向左一圈半打死，车辆继续后退 点位 6：观察右后视镜，当右车身与右侧黄线平行时，“双踩死”（注意两个不：一是不要回正方向盘；二是 “双踩” 时不要松脚），打左转向灯（勿忘），方向盘保持原样，挂前进档一档，3 秒后（倒数 5 个数），松刹车，缓抬离合，车辆前行 点位 7：出库后，当右刮雨器上的 “三角背” 凸点过右侧墙砖时，方向盘向右回一圈半；当左雨刮器上的 “三角背” 凸点与地面左侧黄线重合后，方向盘向右打一圈，车正后方向盘回正，车辆直行。侧方停车操作完成 后续操作：当车辆方向盘越过左侧花坛时，方向盘左打一圈，然后调整方向盘准备切入曲线弯道入口 五、曲线行驶（8 个点位）点位 1：当左刮雨器上的左二铆钉正对路中间，右三铆钉与右黄线重合时，车辆可以进入车道 点位 2：当车辆引擎盖上的 “左龙骨” 完全盖住右侧黄线时，方向盘向左打一圈（360 度） 点位 3：当 “左龙骨” 到右侧地砖中间时，方向盘向左打 90 度（此时方向盘上的雪铁龙车标应该朝左，呈 90 度垂直，左手在 6 点方向，右手在 12 点方向） 点位 4：车辆向左行驶，当 “左龙骨” 的左侧距地面左侧黄线约 10 厘米处时，方向盘迅速向右回正（360 度 + 90 度） 点位 5：当左刮雨器上的右二铆钉与左侧黄线重合时，方向盘向右打一圈（360 度） 点位 6：当左刮雨器上的右二铆钉与左侧地面墙角重合时，方向盘向右打 90 度 点位 7：当 “右龙骨” 与右侧墙砖相交时，方向盘迅速回正（360 度 + 90 度） 点位 8：调整方向盘，让左雨刮器中间缺口切右侧黄线左边线前行，车正后打左转向灯，车辆向前行驶 六、直角转弯（3 个点位）点位 1：头向左微侧，注意看左侧后视镜与车身的夹角，此时如果看见左侧直角时关左转向灯 点位 2：看引擎盖与前方墙角重合时，方向盘左打死，左后车轮越过左侧直角时间距保持 5 厘米左右 点位 3：车辆向左转弯，观察左侧车窗玻璃缝，当玻璃缝与左侧黄线呈 “倒八字形” 时，方向盘回正，车辆前行，出车道 坡道定点停车起步 七、坡道定点停车进入车道：上坡前有三个点位用来观察车身：1. 看车辆 “左龙骨” 的是否正对着坡道 “黄虚横线” 的第二、三条之间的黑线（通俗地说就是与别人走过的轮胎印重合）；2. 看左刮雨器上的左一小铆钉是否正对着第三条虚线左边缘靠右 10 厘米；3. 看左刮雨器中心缺口是否距离右黄线内侧约一指宽）。 开始上坡：上坡之前要提前抬离合，上抬约 3 厘米左右（比平路上要多抬一点），当车盖翘起时，注意稳定离合（如果此车很慢，似走非走，可适当抬高离合，但幅度不宜过大），上坡过程中可以微修方向，但幅度要小，且修完之后方向要迅速回正。※引擎盖顶端从右至左 1/3 处，轧右侧黄线，车身与右边线距离即为 30 公分左右。 定点停车：车辆向前缓慢行驶，当车引擎盖盖过所有黄线后，把脚放在刹车踏板上做好刹车准备。此时身体要坐正，头向前方，用眼睛余光观察，当左后视镜与车身夹角的点距离中间 “黄实线” 上沿约 5-8 厘米处时，先踩刹车后踩离合，“双踩死”（此时车前轮基本上压在黄虚线上）。打左转向灯，拉起手刹约 2 两秒后，放下手刹。 坡道起步：30 秒内车辆要起步，否则会直接挂科。轻抬离合，等车身轻微抖动，当车身抖动幅度较大时，慢松刹车，车辆起步，方向盘向左修 45 度左右，尽快回正。当车辆即将翻坡时再略抬一点离合，越过平台下冲时，将离合踩到底，轻踩刹车，保持匀速缓慢下坡。","categories":[{"name":"考证","slug":"考证","permalink":"http://yoursite.com/categories/%E8%80%83%E8%AF%81/"}],"tags":[{"name":"驾考","slug":"驾考","permalink":"http://yoursite.com/tags/%E9%A9%BE%E8%80%83/"}]},{"title":"驾考科目二要点","slug":"驾考科目二要点","date":"2020-05-31T13:47:59.425Z","updated":"2020-06-04T12:43:09.841Z","comments":true,"path":"2020/05/31/驾考科目二要点/","link":"","permalink":"http://yoursite.com/2020/05/31/%E9%A9%BE%E8%80%83%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%A6%81%E7%82%B9/","excerpt":"[toc] 原来二月份要考的科目二，好久没练车，忘得一干二净……别躺了，6月份开始继续练车。","text":"[toc] 原来二月份要考的科目二，好久没练车，忘得一干二净……别躺了，6月份开始继续练车。 考前准备： 调整座椅，离合器踩到底 后视镜调整：左边能看到后轮（后视镜1/3） 右边压在后门把手 看到 安全带系好，确保不会弹出 检查仪表板 拉手刹测试 倒车入库： 保持1.5米边距的方法：左后视镜下沿一半的位置贴着线 曲线行驶： 打一圈方向，左车角碰线回正，到右边角再打一圈方向，要出口时候稍微往左边回一些方向。 侧方位停车： 出库时候 先打左灯 车头一般盖线一般后回正，慢慢打一圈。 右边1/3盖到线大概是30公分！ 直角转弯： 左侧雨刮器最高点贴右边线行驶 30公分 左门把手对齐直角。 坡道定点起步： 顶点记得挂空挡。 左后视镜下沿要对齐第二根实线。 大一暑假练车计划： 六月一日开始练车。 暑假至少考完科目二，练熟科目三。 变黑警告 1234function fun()&#123; echo \"这是一个日后生活的基本技能\"; &#125; fun(); 六月一日：​ 今天刚去第一天，预约10号考试，简单练了一下全程，坡道定点和曲线行驶点位看不见。这天气是真热！","categories":[{"name":"考证","slug":"考证","permalink":"http://yoursite.com/categories/%E8%80%83%E8%AF%81/"}],"tags":[{"name":"驾考","slug":"驾考","permalink":"http://yoursite.com/tags/%E9%A9%BE%E8%80%83/"}]},{"title":"Github+hexo博客搭建","slug":"Github-hexo博客搭建","date":"2020-05-31T07:23:54.000Z","updated":"2020-06-04T12:43:03.516Z","comments":true,"path":"2020/05/31/Github-hexo博客搭建/","link":"","permalink":"http://yoursite.com/2020/05/31/Github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"hexo静态博客搭建","text":"hexo静态博客搭建 耗费一晚上加一天时间算是搭建好了hexo博客，过程中也遇到很多问题。好在有CSDN的大佬们的文章帮忙。希望能够持续更新博客哦！","categories":[{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://yoursite.com/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}],"categories":[{"name":"编程困惑","slug":"编程困惑","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9B%B0%E6%83%91/"},{"name":"考证","slug":"考证","permalink":"http://yoursite.com/categories/%E8%80%83%E8%AF%81/"},{"name":"实习","slug":"实习","permalink":"http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"hexo博客搭建","slug":"hexo博客搭建","permalink":"http://yoursite.com/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"驾考","slug":"驾考","permalink":"http://yoursite.com/tags/%E9%A9%BE%E8%80%83/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}